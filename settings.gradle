import java.nio.file.Files
import java.util.regex.Matcher
import java.util.regex.Pattern

pluginManagement {
    repositories {
        mavenCentral()
        maven { url 'https://maven.aliyun.com/repository/public' }
        maven { url 'https://maven.aliyun.com/repository/google' }
        maven { url = 'https://maven.aliyun.com/repository/gradle-plugin' }
        maven { url 'https://jitpack.io' }
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    /**
     * FAIL_ON_PROJECT_REPOS:  如果设置此模式，则在项目中直接或通过插件直接声明的任何存储库都将触发构建错误
     * PREFER_PROJECT:         如果设置此模式，则在项目上声明的任何存储库会覆盖设置中声明的存储库
     * PREFER_SETTINGS：       如果设置此模式，则项目中使用的存储库只会以设置中声明的为准
     */
    repositoriesMode.set(RepositoriesMode.PREFER_PROJECT)

    repositories {
        mavenLocal()
        mavenCentral()
        maven { url 'https://maven.aliyun.com/repository/public' } // central 和 jcenter 的聚合仓
        maven { url 'https://maven.aliyun.com/repository/google' }
        maven { url 'https://jitpack.io' }
    }
}

rootProject.name = "BaseProject"

include ':app'
include ':catalog'


def includeBuildProjects = ['libs/project', 'libs/uikit']

includeBuildProjects.forEach {
    println "开始添加构建 -------------> $it"
    includeBuild(it)
}

//setting.gradle 加载和评估配置阶段完成
gradle.settingsEvaluated {
    println '设置加载完毕'
}

//项目加载完成
gradle.projectsLoaded {
    println "${it} ---------> projectsLoaded"

    gradle.rootProject.buildscript {
        println '开始执行初始化配置脚本'
    }
}

def getCurrentFlavor(Project project) {
    Gradle gradle = project.getGradle()
    String tskReqStr = gradle.getStartParameter().getTaskRequests().toString()
    Pattern pattern = Pattern.compile("(assemble|generate|bundle)(.*?)(Release|Debug)")
    Matcher matcher = pattern.matcher(tskReqStr)
    String channel = ""
    if (matcher.find()) {
        channel = matcher.group(2).toLowerCase()
    }
    return channel
}

gradle.addProjectEvaluationListener(new ProjectEvaluationListener() {
    void beforeEvaluate(Project project) {
        println "${project} -------------> beforeEvaluate"
        println "currentFlavor -------------> ${getCurrentFlavor(project)}"
    }

    void afterEvaluate(Project project, ProjectState state) {
        println "${project} -------------> afterEvaluate"
        println "currentFlavor -------------> ${getCurrentFlavor(project)}"
    }
})


//gradle.settingsEvaluated {
//    apply from: 'file_util.gradle'
//    includeBuildProjects.forEach {
//        copyLocalPropertiesForIncludeBuild(it)
//    }
//}


/**
 * Android Studio当前不会为IncludeBuild创建包含sdk.dir的local.properties
 * 使得没有ANDROID_HOME或等效环境变量时仅依赖根目录的local.properties无法编译IncludeBuild。
 * 为了使此含有IncludeBuild的项目和其他不含有IncludeBuild的普通Android工程一样可以在
 * 只有根目录的local.properties情况下正常编译，用此任务复制local.properties。
 */
def copyLocalPropertiesForIncludeBuild(includedBuild) {
    // 同步 buildSrc 配置
    def buildSrc = file('buildSrc')
    if (buildSrc.exists()) {
        def includedBuildBuildSrc = file("${includedBuild}/buildSrc")
        //        if (includedBuildBuildSrc.exists() && includedBuildBuildSrc.isDirectory()) {
        //            includedBuildBuildSrc.deleteDir()
        //        }

        println "开始拷贝根项目的 buildSrc 目录至 ----> $includedBuild 下"
        copyFile(buildSrc, includedBuildBuildSrc)
    }

    def rootFile = file('local.properties')
    if (rootFile.exists()) {
        def includeBuildLocalProperties = file("${includedBuild}/local.properties")
        if (!includeBuildLocalProperties.exists()) {
            Files.copy(rootFile.toPath(), includeBuildLocalProperties.toPath())
        }
    }
}