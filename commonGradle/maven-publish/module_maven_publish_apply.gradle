gradle.beforeProject {
    // 项目配置之前动态添加 buildscript 依赖
    it.buildscript {
        repositories {
            maven { url 'https://maven.aliyun.com/repository/public' }
            maven { url 'https://maven.aliyun.com/repository/google' }
            maven { url 'https://maven.aliyun.com/repository/gradle-plugin' }
            maven { url 'https://jitpack.io' }
            google() // 阿里云对于有些库会有丢失，加入进行兜底
            mavenCentral()
            gradlePluginPortal()
        }

        dependencies {
            // 目前该插件测试要求： Gradle:8.5+   AGP:8.1.0+
            classpath 'com.vanniktech:gradle-maven-publish-plugin:0.33.0'
        }
    }
}


def projectRelativeRootPath = '../../'

//引入 maven 发布配置设置
apply from: rootProject.file(projectRelativeRootPath + './commonGradle/maven-publish/publish_config.gradle').path

subprojects {
    Project project = it

    ext {
        // 定义当前模块名称用于 Maven 发布
        module_name = project.path.drop(1)
    }

    project.afterEvaluate {
        if (project.plugins.hasPlugin('com.android.application')) {
            return
        }

        // maven 发布脚本路径
        def mavenPublishScriptPath = rootProject.file(projectRelativeRootPath +'./commonGradle/maven-publish/MavenPublish.gradle').path
        project.apply from: mavenPublishScriptPath
    }
}



// 在项目依赖构建完成时，向根项目注册聚合任务：发布所有子模块
gradle.projectsEvaluated {
    // 在根项目下创建所有的发布任务
    def publishAllTaskName = ['publishMavenPublicationToMavenLocal', 'publishMavenPublicationToMavenCentralRepository']

    publishAllTaskName.forEach { publishTaskName ->
        def publishAllName = publishTaskName.replace('publishMavenPublication', 'publishAll')

        // 发布所在的仓库名称
        def publishRepositoryName = publishTaskName.split('publishMavenPublicationTo')[1]

        // 在根项目下创建所有的发布任务
        rootProject.tasks.register("${publishAllName}") {
            group = "publishing"
            description = "发布所有组件到 $publishRepositoryName"

            dependsOn(rootProject.subprojects.collect { project ->
                // 目前该插件不支持 local aar 发布，因此相关任务直接获取会失败
                // project.tasks.named(publishTaskName).get().doLast {
                project.tasks.findByName(publishTaskName)?.doLast {
                    logger.lifecycle("✅ 模块 ${project.name} 发布 ${publishRepositoryName} 完成")
                }
            }.findAll { it != null })

            doLast {
                logger.lifecycle("✅ ${rootProject.name} 下的所有模块已发布至 $publishRepositoryName")
            }
        }
    }
}